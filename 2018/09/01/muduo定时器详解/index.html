<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/guigui51.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/guigui51.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/guigui51.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/guigui51.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/guigui51.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/guigui51.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/guigui51.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="muduo提供了三个定时器调用API，主要在Eventloop类中12345678910111213141516TimerId EventLoop::runAt(const Timestamp&amp;amp; time, const TimerCallback&amp;amp; cb)&amp;#123;  return timerQueue_-&amp;gt;addTimer(cb, time, 0.0);&amp;#125;Tim">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo定时器详解">
<meta property="og:url" content="http://wuyang51.space/2018/09/01/muduo定时器详解/index.html">
<meta property="og:site_name" content="龟龟的搬砖之路">
<meta property="og:description" content="muduo提供了三个定时器调用API，主要在Eventloop类中12345678910111213141516TimerId EventLoop::runAt(const Timestamp&amp;amp; time, const TimerCallback&amp;amp; cb)&amp;#123;  return timerQueue_-&amp;gt;addTimer(cb, time, 0.0);&amp;#125;Tim">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-09-01T15:25:14.871Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="muduo定时器详解">
<meta name="twitter:description" content="muduo提供了三个定时器调用API，主要在Eventloop类中12345678910111213141516TimerId EventLoop::runAt(const Timestamp&amp;amp; time, const TimerCallback&amp;amp; cb)&amp;#123;  return timerQueue_-&amp;gt;addTimer(cb, time, 0.0);&amp;#125;Tim">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/guigui51.github.io/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wuyang51.space/2018/09/01/muduo定时器详解/"/>





  <title>muduo定时器详解 | 龟龟的搬砖之路</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/guigui51.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">龟龟的搬砖之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">fighting</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/guigui51.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/guigui51.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/guigui51.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-文章列表">
          <a href="/guigui51.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            文章列表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wuyang51.space/guigui51.github.io/2018/09/01/muduo定时器详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龟龟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guigui51.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龟龟的搬砖之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">muduo定时器详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-01T23:02:02+08:00">
                2018-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>muduo提供了三个定时器调用API，主要在Eventloop类中<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TimerId EventLoop::runAt(<span class="keyword">const</span> Timestamp&amp; time, <span class="keyword">const</span> TimerCallback&amp; cb)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> timerQueue_-&gt;addTimer(cb, time, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimerId EventLoop::runAfter(<span class="keyword">double</span> delay, <span class="keyword">const</span> TimerCallback&amp; cb)</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp time(addTime(Timestamp::now(), delay));                <span class="comment">//addTime(Timestamp::now(), delay)返回一个now+delay的时间戳，然后在调用runAt</span></span><br><span class="line">  <span class="keyword">return</span> runAt(time, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimerId EventLoop::runEvery(<span class="keyword">double</span> interval, <span class="keyword">const</span> TimerCallback&amp; cb)</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp time(addTime(Timestamp::now(), interval));</span><br><span class="line">  <span class="keyword">return</span> timerQueue_-&gt;addTimer(cb, time, interval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现定时器的功能主要由TimerId、Timer、TimerQueue三个类来实现的，其中TimerQueue负责管理真个定时器的队列，可以说是实现定时器的主要功能;Timer就是TimerQueue的管理单元类,每一个超时事件就有一个Timer，这个事件超时到了且结束了就会析构，类似于channel的功能，是辅助TimerQueue管理定时器；TimerId也是一个辅助类，主要是与删除类相关。</p>
<h2 id="TimerQueue类"><a href="#TimerQueue类" class="headerlink" title="TimerQueue类"></a>TimerQueue类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TimerQueue</span><span class="params">(EventLoop* loop)</span></span>;</span><br><span class="line">  ~TimerQueue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Schedules the callback to be run at given time,</span></span><br><span class="line">  <span class="comment">/// repeats if @c interval &gt; 0.0.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Must be thread safe. Usually be called from other threads.</span></span><br><span class="line">  <span class="comment">// 一定是线程安全的，可以跨线程调用。通常情况下被其它线程调用。</span></span><br><span class="line">  <span class="function">TimerId <span class="title">addTimer</span><span class="params">(<span class="keyword">const</span> TimerCallback&amp; cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Timestamp when,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">double</span> interval)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GXX_EXPERIMENTAL_CXX0X__</span></span><br><span class="line">  <span class="function">TimerId <span class="title">addTimer</span><span class="params">(TimerCallback&amp;&amp; cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Timestamp when,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">double</span> interval)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> use unique_ptr&lt;Timer&gt; instead of raw pointers.</span></span><br><span class="line">  <span class="comment">// This requires heterogeneous comparison lookup (N3465) from C++14</span></span><br><span class="line">  <span class="comment">// so that we can find an T* in a set&lt;unique_ptr&lt;T&gt;&gt;.</span></span><br><span class="line">  <span class="comment">// unique_ptr是C++ 11标准的一个独享所有权的智能指针</span></span><br><span class="line">  <span class="comment">// 无法得到指向同一对象的两个unique_ptr指针</span></span><br><span class="line">  <span class="comment">// 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象（而非拷贝构造）</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Entry&gt; TimerList;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Timer*, <span class="keyword">int64_t</span>&gt; ActiveTimer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ActiveTimer&gt; ActiveTimerSet;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下成员函数只可能在其所属的I/O线程中调用，因而不必加锁。</span></span><br><span class="line">  <span class="comment">// 服务器性能杀手之一是锁竞争，所以要尽可能少用锁</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addTimerInLoop</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancelInLoop</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line">  <span class="comment">// called when timerfd alarms</span></span><br><span class="line">  <span class="comment">//定时到的读取函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// move out all expired timers</span></span><br><span class="line">  <span class="comment">// 返回超时的定时器列表</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Entry&gt; getExpired(Timestamp now);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;        <span class="comment">// 所属EventLoop</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> timerfd_;</span><br><span class="line">  Channel timerfdChannel_;</span><br><span class="line">  <span class="comment">// Timer list sorted by expiration</span></span><br><span class="line">  TimerList timers_;<span class="comment">// timers_是按到期时间排序 //定时器集合（有序）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// for cancel()</span></span><br><span class="line">  <span class="comment">// timers_与activeTimers_保存的是相同的数据</span></span><br><span class="line">  <span class="comment">// timers_是按到期时间排序，activeTimers_是按对象地址排序</span></span><br><span class="line">  ActiveTimerSet activeTimers_;<span class="comment">//保存正在活动的定时器（无序）</span></span><br><span class="line">  <span class="keyword">bool</span> callingExpiredTimers_; <span class="comment">/* atomic */</span><span class="comment">//是否正在处理超时事件</span></span><br><span class="line">  ActiveTimerSet cancelingTimers_;<span class="comment">// 保存的是被取消的定时器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Entry&gt; TimerList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Timer*, <span class="keyword">int64_t</span>&gt; ActiveTimer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ActiveTimer&gt; ActiveTimerSet;</span><br></pre></td></tr></table></figure>
<p>这两个数据结构TimerList和ActiveTimer后面或构造成定时器队列的所有定时器集合timers、活跃定时器集合activeTimers和已取消的定时器集合cancelingTimers。TimerList是按时间的顺序排列的，前到后。ActiveTimerSet却是由Timer指针来排序的，也就是Timer的地址。<br>TimerQueue在Eventloop构造的时候通过列表初始化构造，也就是说每个Eventloop就有一个TimerQueue类来管理定时器。下面来解释一下TimerQueue的构造函数。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   TimerQueue<span class="type">::TimerQueue</span>(EventLoop* <span class="keyword">loop</span>)</span><br><span class="line">  : loop_(<span class="keyword">loop</span>),</span><br><span class="line">    timerfd_(createTimerfd()),</span><br><span class="line">    timerfdChannel_(<span class="keyword">loop</span>, timerfd_),</span><br><span class="line">    timers_(),</span><br><span class="line">    callingExpiredTimers_(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">  timerfdChannel_.setReadCallback(</span><br><span class="line">      boost<span class="type">::bind</span>(&amp;TimerQueue<span class="type">::handleRead</span>, this));</span><br><span class="line">  <span class="comment">// we are always reading the timerfd, we disarm it with timerfd_settime.</span></span><br><span class="line">  timerfdChannel_.enableReading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TimerQueue的构造函数只有一种，具体构造过程：会TimerQueue绑定到当前Eventloop线程上；通过createTimerfd()创建一个timerfd_，createTimerfd()实际使用的是timefd族的函数，详细：<br>timerfdChannel是管理超时事件的channel；callingExpiredTimers_是是否处理超时事件的标志。</p>
<h2 id="从Eventloop类中的函数来说明定时器的设置过程"><a href="#从Eventloop类中的函数来说明定时器的设置过程" class="headerlink" title="从Eventloop类中的函数来说明定时器的设置过程"></a>从Eventloop类中的函数来说明定时器的设置过程</h2><p>三个函数最后都是通过调用timerQueue_-&gt;addTimer(cb, time, 0.0)来实现功能的<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TimerId TimerQueue::addTimer(<span class="keyword">const</span> TimerCallback&amp; cb,</span><br><span class="line">                             Timestamp when,</span><br><span class="line">                             <span class="keyword">double</span> interval)</span><br><span class="line">&#123;</span><br><span class="line">  Timer* timer = <span class="keyword">new</span> Timer(cb, when, interval);</span><br><span class="line">  loop_-&gt;runInLoop(</span><br><span class="line">      boost::bind(&amp;TimerQueue::addTimerInLoop, this, timer));</span><br><span class="line">  <span class="keyword">return</span> TimerId(timer, timer-&gt;sequence());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>addTimer函数传入参数：cb超时执行的函数，when什么时候超时，就是未来某刻定时器到的时候，以及是否重复。<br>addTimer函数主要是调用Eventloop的runInLoop来进行处理，而绑定的函数addTimerInLoop函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop::runInLoop(<span class="keyword">const</span> Functor&amp; cb)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (isInLoopThread())</span><br><span class="line">  &#123;</span><br><span class="line">    cb();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    queueInLoop(cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>runInLoop也就是说如果是当前线程马上执行，不是就放入任务队列。调用者runInLoop只是线程相关的问题，实际要执行的函数是addTimerInLoop（）。传参是addTimer传参构造的Timer对象。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void TimerQueue::<span class="keyword">addTimerInLoop(Timer* </span>timer)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread()<span class="comment">;</span></span><br><span class="line">  <span class="keyword">bool </span>earliestChanged = <span class="keyword">insert(timer);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span> if (earliestChanged)</span><br><span class="line">  &#123;</span><br><span class="line">    resetTimerfd(timerfd_, timer-&gt;expiration())<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> addTimerInLoop函数会调用insert函数去插入要操作的Timer到定时器队列中。earliestChanged的作用是如果插入的这个定时器比当前定时器队列中所有的定时器都要早，那么就要从新调整，将当前的Timer的timefd设置到epoll中。下面看下insert函数<br> <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="type">TimerQueue</span>::insert(<span class="type">Timer</span>* timer)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(timers_.size() == activeTimers_.size());</span><br><span class="line">  <span class="built_in">bool</span> earliestChanged = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">Timestamp</span> <span class="keyword">when</span> = timer-&gt;expiration();</span><br><span class="line">  <span class="type">TimerList</span>::<span class="keyword">iterator</span> it = timers_.begin();</span><br><span class="line">  <span class="keyword">if</span> (it == timers_.<span class="keyword">end</span>() || <span class="keyword">when</span> &lt; it-&gt;first)        </span><br><span class="line">          /*</span><br><span class="line">          如果此时定时器集合是空的，或者这个定时触发事件的触发时间在所有全列是最前面的就要重新调整定时,</span><br><span class="line">          这就是标志位earliestChanged的作用，就是插入一个定时器，但是它属于所有定时器队列的最前面的那个，</span><br><span class="line">          就要重新更改当前线程的epoll中timefd。</span><br><span class="line">  */</span><br><span class="line">  &#123;</span><br><span class="line">    earliestChanged = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    std::pair&lt;<span class="type">TimerList</span>::<span class="keyword">iterator</span>, <span class="built_in">bool</span>&gt; <span class="literal">result</span></span><br><span class="line">      = timers_.insert(<span class="type">Entry</span>(<span class="keyword">when</span>, timer));</span><br><span class="line">    assert(<span class="literal">result</span>.second); (<span class="built_in">void</span>)<span class="literal">result</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    std::pair&lt;<span class="type">ActiveTimerSet</span>::<span class="keyword">iterator</span>, <span class="built_in">bool</span>&gt; <span class="literal">result</span></span><br><span class="line">      = activeTimers_.insert(<span class="type">ActiveTimer</span>(timer, timer-&gt;sequence()));</span><br><span class="line">    assert(<span class="literal">result</span>.second); (<span class="built_in">void</span>)<span class="literal">result</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(timers_.size() == activeTimers_.size());</span><br><span class="line">  <span class="keyword">return</span> earliestChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开始的时候判断这个超时是否是最小的，是否是第一个，如果符合其中一个，那就意味这要改变epoll中监听的timefd。<br>然后依次插入timers和activeTimers。set的insert会返回两个参数，一个是插入迭代器的位置，和是否插入成功，因为set中的元素不重复，所以返回的第二个参数是插入是否成功。<br>然后如果earliestChanged为true，也就是说要插入的Timer是定时器队列中的第一个，那么要重新设置超时事件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="keyword">int</span> timerfd, Timestamp expiration)</span>        <span class="comment">//重新设置定时器描述符关注的定时事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// wake up loop by timerfd_settime()</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">newValue</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">oldValue</span>;</span></span><br><span class="line">  bzero(&amp;newValue, <span class="keyword">sizeof</span> newValue);</span><br><span class="line">  bzero(&amp;oldValue, <span class="keyword">sizeof</span> oldValue);</span><br><span class="line">  newValue.it_value = howMuchTimeFromNow(expiration);        <span class="comment">//获得与现在的时间差值，然后设置关注事件</span></span><br><span class="line">  <span class="keyword">int</span> ret = ::timerfd_settime(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">  <span class="keyword">if</span> (ret)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">"timerfd_settime()"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>resetTimerfd函数的传入参数为当前Timer的timefd和超时的时间点，通过timerfd_settime设置当前Timer超时的时间点。说一下howMuchTimeFromNow函数，这个函数的主要功能是获得这个事件的超时时间点距离now还有多少秒。<br>如果小于100微秒就是取100，我认为是为了机器指令的执行，以免出现竞争的情况。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct timespec <span class="title">howMuchTimeFromNow</span><span class="params">(Timestamp when)</span>        <span class="comment">//现在距离超时还有多久</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> microseconds = when.microSecondsSinceEpoch()</span><br><span class="line">                         - Timestamp::now().microSecondsSinceEpoch();</span><br><span class="line">  <span class="keyword">if</span> (microseconds &lt; <span class="number">100</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    microseconds = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">  ts.tv_sec = <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(</span><br><span class="line">      microseconds / Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  ts.tv_nsec = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(</span><br><span class="line">      (microseconds % Timestamp::kMicroSecondsPerSecond) * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="从Eventloop的loop函数说明定时器的运行过程"><a href="#从Eventloop的loop函数说明定时器的运行过程" class="headerlink" title="从Eventloop的loop函数说明定时器的运行过程"></a>从Eventloop的loop函数说明定时器的运行过程</h2><p>定时器怎么知道时间到了，主要还是靠epoll_wait函数，也就是loop中的poller_-&gt;poll。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> <span class="string">EventLoop:</span>:loop()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">assert</span>(!looping_);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  looping_ = <span class="literal">true</span>;</span><br><span class="line">  quit_ = <span class="literal">false</span>;  <span class="comment">// <span class="doctag">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" start looping"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    ++iteration_;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">Logger:</span>:logLevel() &lt;= <span class="string">Logger:</span>:TRACE)</span><br><span class="line">    &#123;</span><br><span class="line">      printActiveChannels();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// TODO sort channel by priority按优先级排序通道</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="string">ChannelList:</span>:iterator it = activeChannels_.begin();</span><br><span class="line">        it != activeChannels_.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = *it;</span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    currentActiveChannel_ = NULL;</span><br><span class="line">    eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">    doPendingFunctors();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" stop looping"</span>;</span><br><span class="line">  looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到构造函数<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TimerQueue<span class="type">::TimerQueue</span>(EventLoop* <span class="keyword">loop</span>)</span><br><span class="line">  : loop_(<span class="keyword">loop</span>),</span><br><span class="line">    timerfd_(createTimerfd()),</span><br><span class="line">    timerfdChannel_(<span class="keyword">loop</span>, timerfd_),</span><br><span class="line">    timers_(),</span><br><span class="line">    callingExpiredTimers_(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">  timerfdChannel_.setReadCallback(</span><br><span class="line">      boost<span class="type">::bind</span>(&amp;TimerQueue<span class="type">::handleRead</span>, this));</span><br><span class="line">  <span class="comment">// we are always reading the timerfd, we disarm it with timerfd_settime.</span></span><br><span class="line">  timerfdChannel_.enableReading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>timerfdChannel就是专门负责管理定时器的channel，在构造函数中设置的setReadCallback函数为TimerQueue::handleRead。而且使能当前channel的读事件。下面来看下TimerQueue::handleRead函数。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void <span class="symbol">TimerQueue:</span><span class="symbol">:handleRead</span>()</span><br><span class="line">&#123;</span><br><span class="line">  loop<span class="number">_</span>-&gt;assertInLoopThread();</span><br><span class="line">  Timestamp now(<span class="symbol">Timestamp:</span><span class="symbol">:now</span>());</span><br><span class="line">  readTimerfd(timerfd<span class="number">_</span>, now);</span><br><span class="line"></span><br><span class="line">  <span class="symbol">std:</span><span class="symbol">:vector&lt;Entry&gt;</span> expired = getExpired(now);        <span class="regexp">//</span>得到定时到的事件</span><br><span class="line"></span><br><span class="line">  callingExpiredTimers<span class="number">_</span> = <span class="keyword">true</span>;</span><br><span class="line">  cancelingTimers<span class="number">_</span>.clear();</span><br><span class="line">  /<span class="regexp">/ safe to callback outside critical section</span></span><br><span class="line"><span class="regexp">  for (std::vector&lt;Entry&gt;::iterator it = expired.begin();                /</span><span class="regexp">/依次运行定时到了的事件</span></span><br><span class="line"><span class="regexp">      it != expired.end(); ++it)</span></span><br><span class="line"><span class="regexp">  &#123;</span></span><br><span class="line"><span class="regexp">    it-&gt;second-&gt;run();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  callingExpiredTimers_ = false;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  reset(expired, now);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>handleRead函数通过getExpired得到定时器的超时的函数，然后依次处理超时的事件，每个Timer都绑定了超时的函数。执行完后通过reset来处理已经执行完的Timer。下面依次介绍getExpired函数和reset函数。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;TimerQueue::Entry&gt; TimerQueue::getExpired(Timestamp now)        <span class="comment">//得到定时到的所有</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">  std::vector&lt;Entry&gt; expired;</span><br><span class="line">  Entry sentry(now, <span class="keyword">reinterpret_cast</span>&lt;Timer*&gt;(UINTPTR_MAX));</span><br><span class="line">  TimerList::iterator <span class="built_in">end</span> = timers_.lower_bound(sentry);        <span class="comment">//二分查找，找到now的位置，由于now是取的定时到了之后的值</span></span><br><span class="line">  assert(<span class="built_in">end</span> == timers_.<span class="built_in">end</span>() || now &lt; <span class="built_in">end</span>-&gt;first);</span><br><span class="line">  std::copy(timers_.<span class="built_in">begin</span>(), <span class="built_in">end</span>, back_inserter(expired));</span><br><span class="line">  timers_.erase(timers_.<span class="built_in">begin</span>(), <span class="built_in">end</span>);        <span class="comment">//删除定时到的事件</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">for</span> (std::vector&lt;Entry&gt;::iterator it = expired.<span class="built_in">begin</span>();</span><br><span class="line">      it != expired.<span class="built_in">end</span>(); ++it)</span><br><span class="line">  &#123;</span><br><span class="line">    ActiveTimer timer(it-&gt;second, it-&gt;second-&gt;sequence());</span><br><span class="line">    size_t n = activeTimers_.erase(timer);</span><br><span class="line">    assert(n == <span class="number">1</span>); (<span class="keyword">void</span>)n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">return</span> expired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getExpired函数有个很有意思地方，它的传入参数是now，也就是定时器超时之后的时间点，这样就避免到了在处理超时事件的同时，有个挨着很紧的时间继续超时。具体操作：将超时的Time全部导入一个待处理的集合expired中，然后在timers集合中删除它们。然后也将activeTimers中的超时Timer也删除。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> void TimerQueue::reset(const std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp nextExpire;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::vector&lt;Entry&gt;::const_iterator it = expired.begin();</span><br><span class="line">      it != expired.end(); ++it)</span><br><span class="line">  &#123;</span><br><span class="line">    A<span class="function"><span class="title">ctiveTimer</span> timer(it-&gt;</span><span class="function"><span class="title">second</span>, it-&gt;</span><span class="function"><span class="title">second</span>-&gt;</span>sequence());</span><br><span class="line">    <span class="function"><span class="title">if</span> (it-&gt;</span><span class="function"><span class="title">second</span>-&gt;</span>repeat()</span><br><span class="line">        &amp;&amp; cancelingTimers_.find(timer) == cancelingTimers_.end())        <span class="comment">//判断是否是重复事件与是否是已经取消的事件？</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">it</span>-&gt;</span><span class="function"><span class="title">second</span>-&gt;</span>restart(now);</span><br><span class="line">      <span class="function"><span class="title">insert</span>(it-&gt;</span>second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// FIXME move to a free list</span></span><br><span class="line">      <span class="function"><span class="title">delete</span> it-&gt;</span>second; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!timers_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="title">nextExpire</span> = timers_.begin()-&gt;</span><span class="function"><span class="title">second</span>-&gt;</span>expiration();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextExpire.valid())</span><br><span class="line">  &#123;</span><br><span class="line">    resetTimerfd(timerfd_, nextExpire);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>reset函数主要是处理超时的Timer，reset主要干这么几件事：判断这个Timer是否是一个重复的事件，就是runEvery调用的，如果是那么重新插入定时器队列，进行调整；如果不是那么这个Timer可以直接析构了。然后指定定时器队列的队首Timer，重新设置超时事件，这个过程已经说了。这就是muduo的定时器的运行过程。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/guigui51.github.io/2018/09/01/16模板与泛形编程/" rel="next" title="16模板与泛形编程">
                <i class="fa fa-chevron-left"></i> 16模板与泛形编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">龟龟</p>
              <p class="site-description motion-element" itemprop="description">一些关于敲代码的事儿</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/guigui51.github.io/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/guigui51.github.io/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#TimerQueue类"><span class="nav-number">1.</span> <span class="nav-text">TimerQueue类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从Eventloop类中的函数来说明定时器的设置过程"><span class="nav-number">2.</span> <span class="nav-text">从Eventloop类中的函数来说明定时器的设置过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从Eventloop的loop函数说明定时器的运行过程"><span class="nav-number">3.</span> <span class="nav-text">从Eventloop的loop函数说明定时器的运行过程</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龟龟</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/guigui51.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/guigui51.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/guigui51.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/guigui51.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/guigui51.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/guigui51.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/guigui51.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/guigui51.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/guigui51.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/guigui51.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/guigui51.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
